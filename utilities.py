import base64
import pandas as pd
from search import VAR_N, BIT_W, get_ints, individual, INP_W, get_binary
from bitarray import bitarray

def convert_64_to_vals(s:str):
    """Converts a base64 Individual name to the list of corresponding variable values

        Args:
            s (str): base64 encoded str

        Returns:
            vals (list of ints): the variable values
    """
    vals = []
    dec_bytes = base64.standard_b64decode(s)
    enc_bits = bitarray(endian='big')               # get a bitarray object
    enc_bits.frombytes(dec_bytes)                   # get bitarray from bytes
    enc_str = enc_bits.to01()                       # get str of bits
    enc_str = enc_str[len(enc_str)-BIT_W*VAR_N:]
    vals = get_ints(enc_str)
    return vals

def convert_64_to_16(s:str):
    """Converts a base64 Individual name to the corresponding base16 Individual name

        Args:
            s (str): base64 encoded str

        Returns:
            (str): corresponding base16 str
    """
    vals = convert_64_to_vals(s)
    ind = individual(vals)
    return ind.short_name()

def convert_16_to_vals(s:str):
    dec_int = int(s, base=16)
    enc_bits = bitarray(endian='big')
    enc_bits.frombytes(dec_int.to_bytes(length=25,byteorder='big'))
    enc_str = enc_bits.to01()
    enc_str = enc_str[len(enc_str)-BIT_W*VAR_N:]
    vals = get_ints(enc_str)
    return vals

def convert_16_to_64(s:str):
    """Converts a base16 Individual name to the corresponding base64 Individual name

        Args:
            s (str): base16 encoded str

        Returns:
            (str): corresponding base64 str
    """
    vals = convert_16_to_vals(s)
    ind = individual(vals)
    return ind.shorter_name()

def create_ax_mult(file):
    """Creates an approximate multiplication table from file.
       File must contain lines with a single multiplication result in each line.
       As generated by our main.tcl script: (0x0)     00000000000000000
                                            (0x1)     00000000000000000
                                            (0x2)     00000000000000000
                                            ...
                                            (255x255) 00111111100000001
                           (File contains only these) ^^^^^^^^^^^^^^^^^
        Anything that is not a binary number is disregarded so UUUU and XXXX are handled.
        But make sure that file contains all the required results.
        
        Args:
            file (file): file containing multiplication results only

        Returns:
            table (list of int): multiplication results
    """
    data = file.readlines()
    table = []
    for b in data:
        try:
            num = int(b.strip('\n'),base=2)
            table.append(num)
        except:
            continue
    return table

def get_ax_mult(a, b, table, width=INP_W):
    """Returns the multiplication of axb from the table.
       Depends on INP_W (input bit width) from search.py, overwrite it if needed.
       !!! Approximate Multiplication is not necessarily commutative, the order of a and b matters !!!

        Args:
            a (int): multiplicand
            b (int): multiplier
            table (list of ints): table that contain the approximate multiplication results
            width (int): bit width of input

        Returns:
            (int): multiplication result
    """
    stride = 2**width
    return table[a*stride+b]

def get_dataframe(highscores):
    """Creates a pandas dataframe from an idividual database dictionary.

        Args:
            highscores (dict[name: individual]): idividual database dictionary

        Returns:
            dt (DataFrame): generated pandas dataframe
    """
    dt = pd.DataFrame(columns = ['score', 'mse', 'util', 'time', 'power', 'vars'],
                      index = list(highscores.keys()))
    for k in highscores.keys():
        dt.loc[k] = pd.Series({'score' : highscores[k].score,
                               'mse' : highscores[k].mse,
                               'util' : highscores[k].util, 
                               'time' : highscores[k].time, 
                               'power' : highscores[k].power, 
                               'vars' : highscores[k].vars})
    return dt
